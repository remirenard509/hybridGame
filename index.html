<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Hybride Caméra</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Space between elements */
            padding: 1.5rem;
            max-width: 90vw;
            width: 100%;
        }
        video, canvas {
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #2d3748; /* Slightly lighter dark background for video/canvas */
            max-width: 100%;
            height: auto;
            display: block;
        }
        /* Hide the video element, we only use it to stream to canvas */
        video {
            display: none;
        }
        canvas {
            border: 2px solid #4a5568; /* Border for canvas */
        }
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        #message {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
            color: #cbd5e0;
            text-align: center;
            min-height: 2.5rem; /* Ensure consistent height */
        }
        .color-control-group {
            background-color: #2d3748;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 500px;
        }
        .color-control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #cbd5e0;
        }
        .color-control-group input[type="range"] {
            width: calc(100% - 40px); /* Adjust width to make space for value display */
            margin-right: 10px;
            vertical-align: middle;
        }
        .color-control-group span {
            display: inline-block;
            width: 30px;
            text-align: right;
            vertical-align: middle;
        }
        .color-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
            }
            video, canvas {
                width: 45%; /* Adjust width for larger screens */
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div class="container">
        <h1 class="text-3xl font-bold text-center w-full">Jeu Hybride Caméra</h1>

        <!-- Video element to capture camera stream -->
        <video id="videoFeed" autoplay playsinline></video>

        <!-- Canvas element to draw video and overlays -->
        <canvas id="gameCanvas"></canvas>

        <div class="button-group w-full">
            <button id="startButton">Démarrer la Caméra</button>
            <button id="stopButton" disabled>Arrêter la Caméra</button>
            <button id="reverseCameraButton" disabled>Inverser Caméra</button>
            <button id="calibrateButton">Calibrer le Plateau</button>
        </div>

        <div id="message" class="w-full">Prêt à démarrer !</div>

        <!-- NOUVEAUX CONTRÔLES DE CALIBRAGE DES COULEURS -->
        <div id="colorCalibrationControls" class="color-control-group">
            <h2 class="text-xl font-bold mb-4 text-center">Calibrage des Couleurs</h2>

            <!-- Contrôles pour le Guerrier (Rouge) -->
            <div class="mb-4">
                <h3 class="font-semibold mb-2">Guerrier (Rouge)</h3>
                <div class="color-row">
                    <label for="redR">R:</label>
                    <input type="range" id="redR" min="0" max="255" value="255">
                    <span id="redRValue">255</span>
                </div>
                <div class="color-row">
                    <label for="redG">G:</label>
                    <input type="range" id="redG" min="0" max="255" value="0">
                    <span id="redGValue">0</span>
                </div>
                <div class="color-row">
                    <label for="redB">B:</label>
                    <input type="range" id="redB" min="0" max="255" value="0">
                    <span id="redBValue">0</span>
                </div>
                <div class="color-row">
                    <label for="redTolerance">Tolérance:</label>
                    <input type="range" id="redTolerance" min="0" max="255" value="75">
                    <span id="redToleranceValue">75</span>
                </div>
            </div>

            <!-- Contrôles pour le Magicien (Vert) -->
            <div class="mb-4">
                <h3 class="font-semibold mb-2">Magicien (Vert)</h3>
                <div class="color-row">
                    <label for="greenR">R:</label>
                    <input type="range" id="greenR" min="0" max="255" value="0">
                    <span id="greenRValue">0</span>
                </div>
                <div class="color-row">
                    <label for="greenG">G:</label>
                    <input type="range" id="greenG" min="0" max="255" value="255">
                    <span id="greenGValue">255</span>
                </div>
                <div class="color-row">
                    <label for="greenB">B:</label>
                    <input type="range" id="greenB" min="0" max="255" value="0">
                    <span id="greenBValue">0</span>
                </div>
                <div class="color-row">
                    <label for="greenTolerance">Tolérance:</label>
                    <input type="range" id="greenTolerance" min="0" max="255" value="75">
                    <span id="greenToleranceValue">75</span>
                </div>
            </div>

            <!-- Contrôles pour le Calibrage (Bleu - Tour) -->
            <div>
                <h3 class="font-semibold mb-2">Calibrage (Bleu - Tour)</h3>
                <div class="color-row">
                    <label for="blueR">R:</label>
                    <input type="range" id="blueR" min="0" max="255" value="0">
                    <span id="blueRValue">0</span>
                </div>
                <div class="color-row">
                    <label for="blueG">G:</label>
                    <input type="range" id="blueG" min="0" max="255" value="0">
                    <span id="blueGValue">0</span>
                </div>
                <div class="color-row">
                    <label for="blueB">B:</label>
                    <input type="range" id="blueB" min="0" max="255" value="255">
                    <span id="blueBValue">255</span>
                </div>
                <div class="color-row">
                    <label for="blueTolerance">Tolérance:</label>
                    <input type="range" id="blueTolerance" min="0" max="255" value="75">
                    <span id="blueToleranceValue">75</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Récupération des éléments du DOM
        const videoFeed = document.getElementById('videoFeed');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const reverseCameraButton = document.getElementById('reverseCameraButton');
        const calibrateButton = document.getElementById('calibrateButton');
        const messageDiv = document.getElementById('message');

        // Références aux éléments UI de calibration des couleurs
        const colorCalibrationControls = document.getElementById('colorCalibrationControls');

        let stream = null;
        let animationFrameId = null;
        let isCameraActive = false;
        let currentFacingMode = 'environment';

        // --- Configuration des Tokens ---
        // Token 1 (Rouge) - Guerrier
        const token1ImageUrl = './assets/guerrier.png';
        const token1Image = new Image();
        token1Image.src = token1ImageUrl;
        token1Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token Guerrier. Vérifiez le chemin :", token1ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token1ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 2 (Vert) - Magicien
        const token2ImageUrl = './assets/magicien.png';
        const token2Image = new Image();
        token2Image.src = token2ImageUrl;
        token2Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token Magicien. Vérifiez le chemin :", token2ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token2ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 3 (Bleu) - Pour le calibrage (Tour)
        const token3ImageUrl = './assets/tour.png';
        const token3Image = new Image();
        token3Image.src = token3ImageUrl;
        token3Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token de calibrage (Tour). Vérifiez le chemin :", token3ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token3ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Taille personnalisable des tokens (diamètre en pixels)
        const tokenSize = 80;

        // --- Optimisation pour la détection ---
        const detectionCanvas = document.createElement('canvas');
        const detectionCtx = detectionCanvas.getContext('2d');
        const detectionWidth = 160; // Résolution de détection

        // --- Variables de calibrage ---
        const GRID_SIZE = 10; // Grille 10x10
        let isCalibrating = false;
        let calibrationPoints = [];
        let calibrationRect = null;
        let gridCellSize = { width: 0, height: 0 };

        // --- Configurations de couleur dynamiques (utilisées pour la détection) ---
        const colorConfigs = {
            red: {
                name: "Guerrier (Rouge)",
                target: { r: 255, g: 0, b: 0 },
                tolerance: 75,
                ui: { // Références aux éléments UI pour cette couleur
                    rInput: document.getElementById('redR'),
                    gInput: document.getElementById('redG'),
                    bInput: document.getElementById('redB'),
                    toleranceInput: document.getElementById('redTolerance'),
                    rValue: document.getElementById('redRValue'),
                    gValue: document.getElementById('redGValue'),
                    bValue: document.getElementById('redBValue'),
                    toleranceValue: document.getElementById('redToleranceValue')
                }
            },
            green: {
                name: "Magicien (Vert)",
                target: { r: 0, g: 255, b: 0 },
                tolerance: 75,
                ui: {
                    rInput: document.getElementById('greenR'),
                    gInput: document.getElementById('greenG'),
                    bInput: document.getElementById('greenB'),
                    toleranceInput: document.getElementById('greenTolerance'),
                    rValue: document.getElementById('greenRValue'),
                    gValue: document.getElementById('greenGValue'),
                    bValue: document.getElementById('greenBValue'),
                    toleranceValue: document.getElementById('greenToleranceValue')
                }
            },
            blue: {
                name: "Calibrage (Bleu - Tour)",
                target: { r: 0, g: 0, b: 255 },
                tolerance: 75,
                ui: {
                    rInput: document.getElementById('blueR'),
                    gInput: document.getElementById('blueG'),
                    bInput: document.getElementById('blueB'),
                    toleranceInput: document.getElementById('blueTolerance'),
                    rValue: document.getElementById('blueRValue'),
                    gValue: document.getElementById('blueGValue'),
                    bValue: document.getElementById('blueBValue'),
                    toleranceValue: document.getElementById('blueToleranceValue')
                }
            }
        };

        // --- Fonctions utilitaires ---

        /**
         * Affiche un message à l'utilisateur.
         * @param {string} msg - Le message à afficher.
         * @param {string} type - Le type de message ('info', 'error', 'success').
         */
        function displayMessage(msg, type = 'info') {
            messageDiv.textContent = msg;
            messageDiv.className = `w-full p-3 rounded-lg text-center ${
                type === 'error' ? 'bg-red-700 text-white' :
                type === 'success' ? 'bg-green-700 text-white' :
                'bg-gray-700 text-gray-200'
            }`;
        }

        /**
         * Convertit une couleur hexadécimale en objet RGB.
         * N'est plus utilisé pour les couleurs cibles, mais peut servir ailleurs.
         * @param {string} hex - La couleur hexadécimale (ex: "#FF0000").
         * @returns {object} - Un objet {r, g, b}.
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        /**
         * Dessine une image dans un cercle sur un contexte de canevas.
         * @param {CanvasRenderingContext2D} context - Le contexte du canevas cible.
         * @param {HTMLImageElement} img - L'objet Image à dessiner.
         * @param {number} x - La coordonnée X du centre du cercle.
         * @param {number} y - La coordonnée Y du centre du cercle.
         * @param {number} diameter - Le diamètre du cercle.
         */
        function drawCircularImage(context, img, x, y, diameter) {
            const radius = diameter / 2;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = diameter;
            tempCtx.height = diameter;

            tempCtx.beginPath();
            tempCtx.arc(radius, radius, radius, 0, Math.PI * 2);
            tempCtx.closePath();
            tempCtx.clip();

            const aspectRatio = img.width / img.height;
            let drawWidth = diameter;
            let drawHeight = diameter;

            if (aspectRatio > 1) {
                drawHeight = diameter / aspectRatio;
            } else {
                drawWidth = diameter * aspectRatio;
            }

            const drawX = radius - drawWidth / 2;
            const drawY = radius - drawHeight / 2;

            tempCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            context.drawImage(tempCanvas, x - radius, y - radius, diameter, diameter);
        }

        /**
         * Dessine la grille de jeu sur le canevas principal.
         * La grille est dessinée en fonction du rectangle de calibrage.
         */
        function drawGrid() {
            if (!calibrationRect) return;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Lignes de grille semi-transparentes
            ctx.lineWidth = 1;

            const { minX, minY, maxX, maxY } = calibrationRect;
            const gridWidth = maxX - minX;
            const gridHeight = maxY - minY;

            // Lignes verticales
            for (let i = 0; i <= GRID_SIZE; i++) {
                const x = minX + (i * gridWidth / GRID_SIZE);
                ctx.beginPath();
                ctx.moveTo(x, minY);
                ctx.lineTo(x, maxY);
                ctx.stroke();
            }

            // Lignes horizontales
            for (let i = 0; i <= GRID_SIZE; i++) {
                const y = minY + (i * gridHeight / GRID_SIZE);
                ctx.beginPath();
                ctx.moveTo(minX, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }
        }

        /**
         * Convertit les coordonnées en pixels (sur le canevas principal) en coordonnées de grille (0-GRID_SIZE-1).
         * @param {number} pixelX - Coordonnée X en pixels.
         * @param {number} pixelY - Coordonnée Y en pixels.
         * @returns {object|null} - {gridX, gridY} ou null si hors grille.
         */
        function mapPixelToGrid(pixelX, pixelY) {
            if (!calibrationRect) return null;

            const { minX, minY, maxX, maxY } = calibrationRect;

            // Vérifier si le pixel est à l'intérieur du rectangle de calibrage
            if (pixelX < minX || pixelX > maxX || pixelY < minY || pixelY > maxY) {
                return null; // Hors grille
            }

            // Normaliser les coordonnées dans la plage [0, 1] par rapport au rectangle de calibrage
            const normalizedX = (pixelX - minX) / (maxX - minX);
            const normalizedY = (pixelY - minY) / (maxY - minY);

            // Convertir en coordonnées de grille (0 à GRID_SIZE-1)
            const gridX = Math.floor(normalizedX * GRID_SIZE);
            const gridY = Math.floor(normalizedY * GRID_SIZE);

            // S'assurer que les coordonnées restent dans les limites de la grille
            return {
                gridX: Math.min(Math.max(0, gridX), GRID_SIZE - 1),
                gridY: Math.min(Math.max(0, gridY), GRID_SIZE - 1)
            };
        }

        // --- Logique de la Caméra et du Canevas ---

        /**
         * Démarre le flux de la caméra et l'affiche sur le canevas.
         */
        async function startCamera() {
            displayMessage('Démarrage de la caméra...');
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } });
                videoFeed.srcObject = stream;

                await new Promise(resolve => {
                    videoFeed.onloadedmetadata = () => {
                        gameCanvas.width = videoFeed.videoWidth;
                        gameCanvas.height = videoFeed.videoHeight;

                        detectionCanvas.width = detectionWidth;
                        detectionCanvas.height = videoFeed.videoHeight * (detectionWidth / videoFeed.videoWidth);

                        displayMessage(`Caméra démarrée. Résolution: ${videoFeed.videoWidth}x${videoFeed.videoHeight}. Mode: ${currentFacingMode === 'environment' ? 'Arrière' : 'Avant'}`);
                        videoFeed.play();
                        resolve();
                    };
                });

                drawVideoFrame();
                isCameraActive = true;

                startButton.disabled = true;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                calibrateButton.disabled = false;
            } catch (err) {
                console.error("Erreur d'accès à la caméra :", err);
                displayMessage(`Impossible d'accéder à la caméra : ${err.name}. Assurez-vous d'avoir autorisé l'accès.`, 'error');
                startButton.disabled = false;
                stopButton.disabled = true;
                reverseCameraButton.disabled = true;
                calibrateButton.disabled = true;
                isCameraActive = false;
            }
        }

        /**
         * Arrête le flux de la caméra.
         */
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                videoFeed.srcObject = null;
                stream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoFeed.pause();
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            displayMessage('Caméra arrêtée.');
            startButton.disabled = false;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            calibrateButton.disabled = true;
            isCameraActive = false;
        }

        /**
         * Démarre le processus de calibrage.
         */
        function startCalibration() {
            isCalibrating = true;
            calibrationPoints = [];
            calibrationRect = null;
            displayMessage('Calibrage : Placez le premier pion BLEU (Tour) dans le coin supérieur gauche du plateau.', 'info');
            calibrateButton.textContent = 'Capture Point 1';
            startButton.disabled = true;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            colorCalibrationControls.style.display = 'none'; // Cacher les contrôles de couleur pendant le calibrage
        }

        /**
         * Capture un point de calibrage.
         * @param {object} detectedPoint - Le point détecté {x, y}.
         */
        function captureCalibrationPoint(detectedPoint) {
            if (calibrationPoints.length < 4) {
                calibrationPoints.push(detectedPoint);
                displayMessage(`Calibrage : Point ${calibrationPoints.length} capturé. Placez le pion BLEU (Tour) dans le coin ${
                    calibrationPoints.length === 1 ? 'supérieur droit' :
                    calibrationPoints.length === 2 ? 'inférieur droit' :
                    calibrationPoints.length === 3 ? 'inférieur gauche' : ''
                } du plateau.`, 'info');
                calibrateButton.textContent = `Capture Point ${calibrationPoints.length + 1}`;
            }

            if (calibrationPoints.length === 4) {
                isCalibrating = false;
                calibrateButton.textContent = 'Calibrer le Plateau';
                startButton.disabled = false;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                colorCalibrationControls.style.display = 'block'; // Afficher les contrôles de couleur après le calibrage
                
                // Sortir les points par Y puis par X pour assurer un ordre (haut-gauche, haut-droit, bas-gauche, bas-droit)
                // C'est une simplification, une vraie homographie serait plus robuste à l'ordre.
                calibrationPoints.sort((a, b) => {
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });

                // Définir le rectangle de calibrage (minX, minY, maxX, maxY)
                // On prend le min/max des 4 points pour former un rectangle englobant
                calibrationRect = {
                    minX: Math.min(...calibrationPoints.map(p => p.x)),
                    minY: Math.min(...calibrationPoints.map(p => p.y)),
                    maxX: Math.max(...calibrationPoints.map(p => p.x)),
                    maxY: Math.max(...calibrationPoints.map(p => p.y))
                };

                // Calculer la taille d'une cellule de grille en pixels
                gridCellSize.width = (calibrationRect.maxX - calibrationRect.minX) / GRID_SIZE;
                gridCellSize.height = (calibrationRect.maxY - calibrationRect.minY) / GRID_SIZE;

                displayMessage('Calibrage terminé ! Le plateau est prêt.', 'success');
            }
        }

        /**
         * Met à jour les valeurs de couleur et de tolérance dans colorConfigs
         * à partir des sliders de l'interface utilisateur.
         */
        function updateColorFromUI() {
            for (const colorKey in colorConfigs) {
                const config = colorConfigs[colorKey];
                if (config.ui.rInput) { // Vérifier que les éléments UI existent
                    config.target.r = parseInt(config.ui.rInput.value);
                    config.target.g = parseInt(config.ui.gInput.value);
                    config.target.b = parseInt(config.ui.bInput.value);
                    config.tolerance = parseInt(config.ui.toleranceInput.value);

                    config.ui.rValue.textContent = config.target.r;
                    config.ui.gValue.textContent = config.target.g;
                    config.ui.bValue.textContent = config.target.b;
                    config.ui.toleranceValue.textContent = config.tolerance;
                }
            }
        }

        /**
         * Initialise les sliders de l'interface utilisateur avec les valeurs par défaut de colorConfigs.
         */
        function initColorCalibrationUI() {
            for (const colorKey in colorConfigs) {
                const config = colorConfigs[colorKey];
                if (config.ui.rInput) {
                    config.ui.rInput.value = config.target.r;
                    config.ui.gInput.value = config.target.g;
                    config.ui.bInput.value = config.target.b;
                    config.ui.toleranceInput.value = config.tolerance;

                    // Mettre à jour les afficheurs de valeurs
                    config.ui.rValue.textContent = config.target.r;
                    config.ui.gValue.textContent = config.target.g;
                    config.ui.bValue.textContent = config.target.b;
                    config.ui.toleranceValue.textContent = config.tolerance;

                    // Ajouter les écouteurs d'événements
                    config.ui.rInput.addEventListener('input', updateColorFromUI);
                    config.ui.gInput.addEventListener('input', updateColorFromUI);
                    config.ui.bInput.addEventListener('input', updateColorFromUI);
                    config.ui.toleranceInput.addEventListener('input', updateColorFromUI);
                }
            }
        }


        /**
         * Dessine le flux vidéo sur le canevas et effectue une détection simplifiée.
         */
        function drawVideoFrame() {
            if (videoFeed.paused || videoFeed.ended || videoFeed.readyState < videoFeed.HAVE_CURRENT_DATA) {
                animationFrameId = requestAnimationFrame(drawVideoFrame);
                return;
            }

            ctx.drawImage(videoFeed, 0, 0, gameCanvas.width, gameCanvas.height);
            detectionCtx.drawImage(videoFeed, 0, 0, detectionCanvas.width, detectionCanvas.height);

            const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
            const data = imageData.data;

            // Réinitialiser les pixels détectés pour chaque couleur à chaque frame
            for (const colorKey in colorConfigs) {
                colorConfigs[colorKey].detectedPixels = [];
            }

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const x = (i / 4) % detectionCanvas.width;
                const y = Math.floor((i / 4) / detectionCanvas.width);

                // Détection pour chaque couleur configurée
                for (const colorKey in colorConfigs) {
                    const config = colorConfigs[colorKey];
                    if (colorKey === 'blue' && !isCalibrating) { // Détecter le bleu UNIQUEMENT pendant le calibrage
                        continue;
                    }

                    if (Math.abs(r - config.target.r) < config.tolerance &&
                        Math.abs(g - config.target.g) < config.tolerance &&
                        Math.abs(b - config.target.b) < config.tolerance) {
                        config.detectedPixels.push({ x, y });
                    }
                }
            }

            let message = 'Aucun pion détecté. Placez des objets rouge et vert devant la caméra.';
            const scaleX = gameCanvas.width / detectionCanvas.width;
            const scaleY = gameCanvas.height / detectionCanvas.height;

            // --- Logique de Calibrage ---
            if (isCalibrating) {
                const blueConfig = colorConfigs.blue;
                if (blueConfig.detectedPixels.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    blueConfig.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / blueConfig.detectedPixels.length;
                    const detectionCenterY = sumY / blueConfig.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    // Dessine le pion bleu (Tour) en cours de détection
                    if (token3Image.complete && token3Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token3Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.7)'; // Fallback bleu
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('CALIB', centerX, centerY);
                    }
                }
                // Le message de calibrage est déjà géré par captureCalibrationPoint
            } else {
                // --- Dessin de la grille si calibrée ---
                if (calibrationRect) {
                    drawGrid();
                }

                // --- Dessine les Tokens Joueurs (Rouge et Vert) si détectés ---
                const redConfig = colorConfigs.red;
                const greenConfig = colorConfigs.green;

                let redDetected = false;
                let greenDetected = false;

                if (redConfig.detectedPixels.length > 0) {
                    redDetected = true;
                    let sumX = 0;
                    let sumY = 0;
                    redConfig.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / redConfig.detectedPixels.length;
                    const detectionCenterY = sumY / redConfig.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token1Image.complete && token1Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token1Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; // Fallback rouge
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('GUERRIER', centerX, centerY);
                    }
                    
                    const gridPos = mapPixelToGrid(centerX, centerY);
                    if (gridPos) {
                        message = `Guerrier (Rouge) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                    } else {
                        message = `Guerrier (Rouge) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                    }
                }

                if (greenConfig.detectedPixels.length > 0) {
                    greenDetected = true;
                    let sumX = 0;
                    let sumY = 0;
                    greenConfig.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / greenConfig.detectedPixels.length;
                    const detectionCenterY = sumY / greenConfig.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token2Image.complete && token2Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token2Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.7)'; // Fallback vert
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('MAGICIEN', centerX, centerY);
                    }
                    const gridPos = mapPixelToGrid(centerX, centerY);
                    if (gridPos) {
                        if (redDetected) {
                            message += ` et Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                        } else {
                            message = `Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                        }
                    } else {
                         if (redDetected) {
                            message += ` et Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                        } else {
                            message = `Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                        }
                    }
                }

                if (!redDetected && !greenDetected) {
                    message = 'Aucun pion détecté. Placez des objets rouge et vert devant la caméra.';
                }
            }
            
            displayMessage(message);

            animationFrameId = requestAnimationFrame(drawVideoFrame);
        }

        // --- Gestionnaires d'événements ---
        startButton.addEventListener('click', startCamera);
        stopButton.addEventListener('click', stopCamera);

        reverseCameraButton.addEventListener('click', () => {
            if (stream) {
                stopCamera();
                currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                startCamera();
            }
        });

        // Gestionnaire d'événements pour le bouton de calibrage
        calibrateButton.addEventListener('click', () => {
            if (!isCalibrating) {
                startCalibration();
            } else {
                if (calibrationPoints.length < 4) {
                    const blueConfig = colorConfigs.blue;
                    const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
                    const data = imageData.data;
                    let currentBlueDetectedPixels = [];

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        if (Math.abs(r - blueConfig.target.r) < blueConfig.tolerance &&
                            Math.abs(g - blueConfig.target.g) < blueConfig.tolerance &&
                            Math.abs(b - blueConfig.target.b) < blueConfig.tolerance) {
                            const x = (i / 4) % detectionCanvas.width;
                            const y = Math.floor((i / 4) / detectionCanvas.width);
                            currentBlueDetectedPixels.push({ x, y });
                        }
                    }

                    if (currentBlueDetectedPixels.length > 0) {
                        let sumX = 0;
                        let sumY = 0;
                        currentBlueDetectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                        const detectionCenterX = sumX / currentBlueDetectedPixels.length;
                        const detectionCenterY = sumY / currentBlueDetectedPixels.length;
                        const centerX = detectionCenterX * scaleX;
                        const centerY = detectionCenterY * scaleY;

                        captureCalibrationPoint({ x: centerX, y: centerY });
                    } else {
                        displayMessage('Calibrage : Aucun pion BLEU (Tour) détecté. Placez le pion et réessayez.', 'error');
                    }
                }
            }
        });


        window.addEventListener('beforeunload', stopCamera);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (stream && isCameraActive) {
                    videoFeed.pause();
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    displayMessage('Application en arrière-plan. Caméra en pause.');
                }
            } else {
                if (stream && isCameraActive) {
                    videoFeed.play();
                    drawVideoFrame();
                    displayMessage('Application revenue au premier plan. Caméra reprise.');
                }
            }
        });

        // Initialisation des sliders de calibration des couleurs au chargement de la page
        document.addEventListener('DOMContentLoaded', initColorCalibrationUI);

        stopButton.disabled = true;
        reverseCameraButton.disabled = true;
        calibrateButton.disabled = true;
    </script>
</body>
</html>
