<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Hybride Caméra</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Space between elements */
            padding: 1.5rem;
            max-width: 90vw;
            width: 100%;
        }
        video, canvas {
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #2d3748; /* Slightly lighter dark background for video/canvas */
            max-width: 100%;
            height: auto;
            display: block;
        }
        /* Hide the video element, we only use it to stream to canvas */
        video {
            display: none;
        }
        canvas {
            border: 2px solid #4a5568; /* Border for canvas */
        }
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        #message {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
            color: #cbd5e0;
            text-align: center;
            min-height: 2.5rem; /* Ensure consistent height */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
            }
            video, canvas {
                width: 45%; /* Adjust width for larger screens */
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div class="container">
        <h1 class="text-3xl font-bold text-center w-full">Jeu Hybride Caméra</h1>

        <!-- Video element to capture camera stream -->
        <video id="videoFeed" autoplay playsinline></video>

        <!-- Canvas element to draw video and overlays -->
        <canvas id="gameCanvas"></canvas>

        <div class="button-group w-full">
            <button id="startButton">Démarrer la Caméra</button>
            <button id="stopButton" disabled>Arrêter la Caméra</button>
            <button id="reverseCameraButton" disabled>Inverser Caméra</button>
        </div>

        <div id="message" class="w-full">Prêt à démarrer !</div>
    </div>

    <script>
        // Récupération des éléments du DOM
        const videoFeed = document.getElementById('videoFeed');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const reverseCameraButton = document.getElementById('reverseCameraButton');
        const messageDiv = document.getElementById('message');

        let stream = null;
        let animationFrameId = null;
        let isCameraActive = false;
        let currentFacingMode = 'environment'; // 'environment' pour la caméra arrière, 'user' pour la caméra avant

        // --- Configuration des Tokens ---
        // Token 1 (Rouge)
        const token1ImageUrl = './assets/cheval.png'; // REMPLACE par le nom réel de ton fichier image
        const token1Image = new Image();
        token1Image.src = token1ImageUrl;
        token1Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token 1. Vérifiez le chemin :", token1ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token1ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 2 (Vert)
        const token2ImageUrl = './assets/chien.webp'; // REMPLACE par le nom réel de ton fichier image (par exemple, tour.png)
        const token2Image = new Image();
        token2Image.src = token2ImageUrl;
        token2Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token 2. Vérifiez le chemin :", token2ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token2ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Taille personnalisable des tokens (diamètre en pixels)
        const tokenSize = 80;

        // --- Optimisation pour la détection ---
        const detectionCanvas = document.createElement('canvas');
        const detectionCtx = detectionCanvas.getContext('2d');
        const detectionWidth = 160; // Résolution de détection

        // --- Fonctions utilitaires ---

        /**
         * Affiche un message à l'utilisateur.
         * @param {string} msg - Le message à afficher.
         * @param {string} type - Le type de message ('info', 'error', 'success').
         */
        function displayMessage(msg, type = 'info') {
            messageDiv.textContent = msg;
            messageDiv.className = `w-full p-3 rounded-lg text-center ${
                type === 'error' ? 'bg-red-700 text-white' :
                type === 'success' ? 'bg-green-700 text-white' :
                'bg-gray-700 text-gray-200'
            }`;
        }

        /**
         * Convertit une couleur hexadécimale en objet RGB.
         * @param {string} hex - La couleur hexadécimale (ex: "#FF0000").
         * @returns {object} - Un objet {r, g, b}.
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        /**
         * Dessine une image dans un cercle sur un contexte de canevas.
         * @param {CanvasRenderingContext2D} context - Le contexte du canevas cible.
         * @param {HTMLImageElement} img - L'objet Image à dessiner.
         * @param {number} x - La coordonnée X du centre du cercle.
         * @param {number} y - La coordonnée Y du centre du cercle.
         * @param {number} diameter - Le diamètre du cercle.
         */
        function drawCircularImage(context, img, x, y, diameter) {
            const radius = diameter / 2;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = diameter;
            tempCanvas.height = diameter;

            tempCtx.beginPath();
            tempCtx.arc(radius, radius, radius, 0, Math.PI * 2);
            tempCtx.closePath();
            tempCtx.clip();

            const aspectRatio = img.width / img.height;
            let drawWidth = diameter;
            let drawHeight = diameter;

            if (aspectRatio > 1) {
                drawHeight = diameter / aspectRatio;
            } else {
                drawWidth = diameter * aspectRatio;
            }

            const drawX = radius - drawWidth / 2;
            const drawY = radius - drawHeight / 2;

            tempCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            context.drawImage(tempCanvas, x - radius, y - radius, diameter, diameter);
        }

        /**
         * Démarre le flux de la caméra et l'affiche sur le canevas.
         */
        async function startCamera() {
            displayMessage('Démarrage de la caméra...');
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } });
                videoFeed.srcObject = stream;

                await new Promise(resolve => {
                    videoFeed.onloadedmetadata = () => {
                        gameCanvas.width = videoFeed.videoWidth;
                        gameCanvas.height = videoFeed.videoHeight;

                        detectionCanvas.width = detectionWidth;
                        detectionCanvas.height = videoFeed.videoHeight * (detectionWidth / videoFeed.videoWidth);

                        displayMessage(`Caméra démarrée. Résolution: ${videoFeed.videoWidth}x${videoFeed.videoHeight}. Mode: ${currentFacingMode === 'environment' ? 'Arrière' : 'Avant'}`);
                        videoFeed.play();
                        resolve();
                    };
                });

                drawVideoFrame();
                isCameraActive = true;

                startButton.disabled = true;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
            } catch (err) {
                console.error("Erreur d'accès à la caméra :", err);
                displayMessage(`Impossible d'accéder à la caméra : ${err.name}. Assurez-vous d'avoir autorisé l'accès.`, 'error');
                startButton.disabled = false;
                stopButton.disabled = true;
                reverseCameraButton.disabled = true;
                isCameraActive = false;
            }
        }

        /**
         * Arrête le flux de la caméra.
         */
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                videoFeed.srcObject = null;
                stream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoFeed.pause();
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            displayMessage('Caméra arrêtée.');
            startButton.disabled = false;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            isCameraActive = false;
        }

        /**
         * Dessine le flux vidéo sur le canevas et effectue une détection simplifiée.
         */
        function drawVideoFrame() {
            if (videoFeed.paused || videoFeed.ended || videoFeed.readyState < videoFeed.HAVE_CURRENT_DATA) {
                animationFrameId = requestAnimationFrame(drawVideoFrame);
                return;
            }

            ctx.drawImage(videoFeed, 0, 0, gameCanvas.width, gameCanvas.height);
            detectionCtx.drawImage(videoFeed, 0, 0, detectionCanvas.width, detectionCanvas.height);

            const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
            const data = imageData.data;

            // --- Détection du Token 1 (Rouge) ---
            const targetColor1 = hexToRgb("#FF0000"); // Rouge pur
            const tolerance1 = 100;
            let detectedPixels1 = [];

            // --- Détection du Token 2 (Vert) ---
            const targetColor2 = hexToRgb("#00FF00"); // Vert pur
            const tolerance2 = 100; // Tu peux ajuster cette tolérance pour le vert
            let detectedPixels2 = [];

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Détection du Token 1 (Rouge)
                if (Math.abs(r - targetColor1.r) < tolerance1 &&
                    Math.abs(g - targetColor1.g) < tolerance1 &&
                    Math.abs(b - targetColor1.b) < tolerance1) {
                    
                    const x = (i / 4) % detectionCanvas.width;
                    const y = Math.floor((i / 4) / detectionCanvas.width);
                    detectedPixels1.push({ x, y });
                }
                
                // Détection du Token 2 (Vert) - Ajouté
                if (Math.abs(r - targetColor2.r) < tolerance2 &&
                    Math.abs(g - targetColor2.g) < tolerance2 &&
                    Math.abs(b - targetColor2.b) < tolerance2) {
                    
                    const x = (i / 4) % detectionCanvas.width;
                    const y = Math.floor((i / 4) / detectionCanvas.width);
                    detectedPixels2.push({ x, y });
                }
            }

            let message = 'Aucun pion détecté. Essayez de placer des objets rouge et vert devant la caméra.';
            const scaleX = gameCanvas.width / detectionCanvas.width;
            const scaleY = gameCanvas.height / detectionCanvas.height;

            // Dessine le Token 1 si détecté
            if (detectedPixels1.length > 0) {
                let sumX = 0;
                let sumY = 0;
                detectedPixels1.forEach(p => { sumX += p.x; sumY += p.y; });
                const detectionCenterX = sumX / detectedPixels1.length;
                const detectionCenterY = sumY / detectedPixels1.length;
                const centerX = detectionCenterX * scaleX;
                const centerY = detectionCenterY * scaleY;

                if (token1Image.complete && token1Image.naturalHeight !== 0) {
                    drawCircularImage(ctx, token1Image, centerX, centerY, tokenSize);
                } else {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; // Fallback rouge
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'white';
                    ctx.stroke();
                    ctx.closePath();
                    ctx.fillStyle = 'white';
                    ctx.font = `${tokenSize / 3}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('PION 1', centerX, centerY);
                }
                message = `Pion Rouge détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} !`;
            }

            // Dessine le Token 2 si détecté
            if (detectedPixels2.length > 0) {
                let sumX = 0;
                let sumY = 0;
                detectedPixels2.forEach(p => { sumX += p.x; sumY += p.y; });
                const detectionCenterX = sumX / detectedPixels2.length;
                const detectionCenterY = sumY / detectedPixels2.length;
                const centerX = detectionCenterX * scaleX;
                const centerY = detectionCenterY * scaleY;

                if (token2Image.complete && token2Image.naturalHeight !== 0) {
                    drawCircularImage(ctx, token2Image, centerX, centerY, tokenSize);
                } else {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)'; // Fallback vert
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'white';
                    ctx.stroke();
                    ctx.closePath();
                    ctx.fillStyle = 'white';
                    ctx.font = `${tokenSize / 3}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('PION 2', centerX, centerY);
                }
                // Si les deux sont détectés, ajuster le message
                if (detectedPixels1.length > 0) {
                    message += ` et Pion Vert détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} !`;
                } else {
                    message = `Pion Vert détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} !`;
                }
            }
            
            displayMessage(message);

            animationFrameId = requestAnimationFrame(drawVideoFrame);
        }

        // --- Gestionnaires d'événements ---
        startButton.addEventListener('click', startCamera);
        stopButton.addEventListener('click', stopCamera);

        reverseCameraButton.addEventListener('click', () => {
            if (stream) {
                stopCamera();
                currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                startCamera();
            }
        });

        window.addEventListener('beforeunload', stopCamera);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (stream && isCameraActive) {
                    videoFeed.pause();
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    displayMessage('Application en arrière-plan. Caméra en pause.');
                }
            } else {
                if (stream && isCameraActive) {
                    videoFeed.play();
                    drawVideoFrame();
                    displayMessage('Application revenue au premier plan. Caméra reprise.');
                }
            }
        });

        stopButton.disabled = true;
        reverseCameraButton.disabled = true;
    </script>
</body>
</html>
