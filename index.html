<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Hybride Caméra</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden; /* Prevent horizontal scrollbars */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Space between elements */
            padding: 1.5rem;
            max-width: 90vw; /* Max width for larger screens */
            width: 100%; /* Full width on smaller screens */
        }
        video, canvas {
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #2d3748; /* Slightly lighter dark background for video/canvas */
            max-width: 100%; /* Ensure it doesn't overflow */
            height: auto; /* Maintain aspect ratio */
            display: block;
        }
        /* Hide the video element, we only use it to stream to canvas */
        video {
            display: none;
        }
        canvas {
            border: 2px solid #4a5568; /* Border for canvas */
        }
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap; /* Allow buttons to wrap to next line */
            justify-content: center;
            width: 100%; /* Ensure button group takes full width */
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            cursor: pointer;
            flex-grow: 1; /* Allow buttons to grow and fill space */
            min-width: 150px; /* Minimum width for buttons */
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        #message {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
            color: #cbd5e0;
            text-align: center;
            min-height: 2.5rem; /* Ensure consistent height */
            width: 100%; /* Ensure message takes full width */
        }
        .color-control-group {
            background-color: #2d3748;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            width: 100%; /* Full width on smaller screens */
            max-width: 500px; /* Max width for larger screens */
        }
        .color-control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #cbd5e0;
        }
        .color-control-group input[type="range"] {
            width: calc(100% - 40px); /* Adjust width to make space for value display */
            margin-right: 10px;
            vertical-align: middle;
        }
        .color-control-group span {
            display: inline-block;
            width: 30px;
            text-align: right;
            vertical-align: middle;
        }
        .color-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            flex-wrap: wrap; /* Allow elements in color row to wrap */
        }
        .color-row label, .color-row span {
            flex-shrink: 0; /* Prevent label/span from shrinking */
        }
        .color-row input[type="range"] {
            flex-grow: 1; /* Allow slider to take available space */
        }


        /* Responsive adjustments for larger screens (md breakpoint from Tailwind) */
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
                max-width: 90vw; /* Restore max-width for desktop */
            }
            video, canvas {
                width: 45%; /* Adjust width for larger screens */
            }
            .button-group {
                flex-wrap: nowrap; /* Prevent wrapping on larger screens */
                justify-content: center;
                width: auto; /* Let buttons size naturally */
            }
            button {
                flex-grow: 0; /* Reset flex-grow for larger screens */
            }
            .color-control-group {
                width: 100%; /* Ensure it takes full width within its container */
            }
            .color-row input[type="range"] {
                width: calc(100% - 40px); /* Original width for larger screens */
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div class="container">
        <h1 class="text-3xl font-bold text-center w-full">Jeu Hybride Caméra</h1>

        <!-- Video element to capture camera stream -->
        <video id="videoFeed" autoplay playsinline></video>

        <!-- Canvas element to draw video and overlays -->
        <canvas id="gameCanvas"></canvas>

        <div class="button-group w-full">
            <button id="startButton">Démarrer la Caméra</button>
            <button id="stopButton" disabled>Arrêter la Caméra</button>
            <button id="reverseCameraButton" disabled>Inverser Caméra</button>
            <button id="calibrateColorsButton">Calibrer les Couleurs</button> <!-- Nouveau bouton pour calibration des couleurs -->
            <button id="calibrateBoardButton" disabled>Calibrer le Plateau</button> <!-- Bouton pour calibration du plateau -->
        </div>

        <div id="message" class="w-full">Prêt à démarrer !</div>

        <!-- CONTRÔLES DE CALIBRAGE DES COULEURS -->
        <div id="colorCalibrationControls" class="color-control-group" style="display: none;">
            <h2 class="text-xl font-bold mb-4 text-center">Calibrage des Couleurs</h2>

            <!-- Contrôles pour le Guerrier (Rouge) -->
            <div class="mb-4">
                <h3 class="font-semibold mb-2">Guerrier (Rouge)</h3>
                <div class="color-row">
                    <label for="redR">R:</label>
                    <input type="range" id="redR" min="0" max="255" value="255">
                    <span id="redRValue">255</span>
                </div>
                <div class="color-row">
                    <label for="redG">G:</label>
                    <input type="range" id="redG" min="0" max="255" value="0">
                    <span id="redGValue">0</span>
                </div>
                <div class="color-row">
                    <label for="redB">B:</label>
                    <input type="range" id="redB" min="0" max="255" value="0">
                    <span id="redBValue">0</span>
                </div>
                <div class="color-row">
                    <label for="redTolerance">Tolérance:</label>
                    <input type="range" id="redTolerance" min="0" max="255" value="75">
                    <span id="redToleranceValue">75</span>
                </div>
            </div>

            <!-- Contrôles pour le Magicien (Vert) -->
            <div class="mb-4">
                <h3 class="font-semibold mb-2">Magicien (Vert)</h3>
                <div class="color-row">
                    <label for="greenR">R:</label>
                    <input type="range" id="greenR" min="0" max="255" value="0">
                    <span id="greenRValue">0</span>
                </div>
                <div class="color-row">
                    <label for="greenG">G:</label>
                    <input type="range" id="greenG" min="0" max="255" value="255">
                    <span id="greenGValue">255</span>
                </div>
                <div class="color-row">
                    <label for="greenB">B:</label>
                    <input type="range" id="greenB" min="0" max="255" value="0">
                    <span id="greenBValue">0</span>
                </div>
                <div class="color-row">
                    <label for="greenTolerance">Tolérance:</label>
                    <input type="range" id="greenTolerance" min="0" max="255" value="75">
                    <span id="greenToleranceValue">75</span>
                </div>
            </div>

            <!-- Contrôles pour le Calibrage (Bleu - Tour) -->
            <div>
                <h3 class="font-semibold mb-2">Calibrage (Bleu - Tour)</h3>
                <div class="color-row">
                    <label for="blueR">R:</label>
                    <input type="range" id="blueR" min="0" max="255" value="0">
                    <span id="blueRValue">0</span>
                </div>
                <div class="color-row">
                    <label for="blueG">G:</label>
                    <input type="range" id="blueG" min="0" max="255" value="0">
                    <span id="blueGValue">0</span>
                </div>
                <div class="color-row">
                    <label for="blueB">B:</label>
                    <input type="range" id="blueB" min="0" max="255" value="255">
                    <span id="blueBValue">255</span>
                </div>
                <div class="color-row">
                    <label for="blueTolerance">Tolérance:</label>
                    <input type="range" id="blueTolerance" min="0" max="255" value="75">
                    <span id="blueToleranceValue">75</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Récupération des éléments du DOM
        const videoFeed = document.getElementById('videoFeed');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const reverseCameraButton = document.getElementById('reverseCameraButton');
        const calibrateColorsButton = document.getElementById('calibrateColorsButton'); // Nouveau bouton
        const calibrateBoardButton = document.getElementById('calibrateBoardButton'); // Ancien bouton de calibrage
        const messageDiv = document.getElementById('message');

        // Références aux éléments UI de calibration des couleurs
        const colorCalibrationControls = document.getElementById('colorCalibrationControls');

        let stream = null;
        let animationFrameId = null;
        let isCameraActive = false;
        let currentFacingMode = 'environment';

        // --- Configuration des Tokens ---
        // Token 1 (Rouge) - Guerrier
        const token1ImageUrl = './assets/guerrier.png';
        const token1Image = new Image();
        token1Image.src = token1ImageUrl;
        token1Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token Guerrier. Vérifiez le chemin :", token1ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token1ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 2 (Vert) - Magicien
        const token2ImageUrl = './assets/magicien.png';
        const token2Image = new Image();
        token2Image.src = token2ImageUrl;
        token2Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token Magicien. Vérifiez le chemin :", token2ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token2ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 3 (Bleu) - Pour le calibrage (Tour)
        const token3ImageUrl = './assets/tour.png';
        const token3Image = new Image();
        token3Image.src = token3ImageUrl;
        token3Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token de calibrage (Tour). Vérifiez le chemin :", token3ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token3ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Taille personnalisable des tokens (diamètre en pixels)
        const tokenSize = 80;

        // --- Optimisation pour la détection ---
        const detectionCanvas = document.createElement('canvas');
        const detectionCtx = detectionCanvas.getContext('2d');
        const detectionWidth = 160; // Résolution de détection

        // --- Variables de calibration du plateau ---
        const GRID_SIZE = 10; // Grille 10x10
        let isBoardCalibrating = false; // Renommé pour plus de clarté
        let calibrationPoints = [];
        let calibrationRect = null;
        let gridCellSize = { width: 0, height: 0 };

        // --- Variables de calibration des couleurs ---
        let isColorCalibrating = false;
        let colorCalibrationStep = 'none'; // 'none', 'red_pawn_placement', 'red_pawn_capture', 'green_pawn_placement', etc.
        const colorCalibrationOrder = ['red', 'green', 'blue'];
        let currentColorIndex = 0;

        // --- Configurations de couleur dynamiques (utilisées pour la détection) ---
        const colorConfigs = {
            red: {
                name: "Guerrier (Rouge)",
                tokenImage: token1Image, // Ajout de la référence à l'image du token
                target: { r: 255, g: 0, b: 0 },
                tolerance: 75,
                detectedPixels: [], // Pour stocker les pixels détectés de cette couleur
                ui: { // Références aux éléments UI pour cette couleur
                    rInput: document.getElementById('redR'),
                    gInput: document.getElementById('redG'),
                    bInput: document.getElementById('redB'),
                    toleranceInput: document.getElementById('redTolerance'),
                    rValue: document.getElementById('redRValue'),
                    gValue: document.getElementById('redGValue'),
                    bValue: document.getElementById('redBValue'),
                    toleranceValue: document.getElementById('redToleranceValue')
                }
            },
            green: {
                name: "Magicien (Vert)",
                tokenImage: token2Image, // Ajout de la référence à l'image du token
                target: { r: 0, g: 255, b: 0 },
                tolerance: 75,
                detectedPixels: [],
                ui: {
                    rInput: document.getElementById('greenR'),
                    gInput: document.getElementById('greenG'),
                    bInput: document.getElementById('greenB'),
                    toleranceInput: document.getElementById('greenTolerance'),
                    rValue: document.getElementById('greenRValue'),
                    gValue: document.getElementById('greenGValue'),
                    bValue: document.getElementById('greenBValue'),
                    toleranceValue: document.getElementById('greenToleranceValue')
                }
            },
            blue: {
                name: "Calibrage (Bleu - Tour)",
                tokenImage: token3Image, // Ajout de la référence à l'image du token
                target: { r: 0, g: 0, b: 255 },
                tolerance: 75,
                detectedPixels: [],
                ui: {
                    rInput: document.getElementById('blueR'),
                    gInput: document.getElementById('blueG'),
                    bInput: document.getElementById('blueB'),
                    toleranceInput: document.getElementById('blueTolerance'),
                    rValue: document.getElementById('blueRValue'),
                    gValue: document.getElementById('blueGValue'),
                    bValue: document.getElementById('blueBValue'),
                    toleranceValue: document.getElementById('blueToleranceValue')
                }
            }
        };

        // --- Fonctions utilitaires ---

        /**
         * Affiche un message à l'utilisateur.
         * @param {string} msg - Le message à afficher.
         * @param {string} type - Le type de message ('info', 'error', 'success').
         */
        function displayMessage(msg, type = 'info') {
            messageDiv.textContent = msg;
            messageDiv.className = `w-full p-3 rounded-lg text-center ${
                type === 'error' ? 'bg-red-700 text-white' :
                type === 'success' ? 'bg-green-700 text-white' :
                'bg-gray-700 text-gray-200'
            }`;
        }

        /**
         * Convertit une couleur hexadécimale en objet RGB.
         * @param {string} hex - La couleur hexadécimale (ex: "#FF0000").
         * @returns {object} - Un objet {r, g, b}.
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        /**
         * Dessine une image dans un cercle sur un contexte de canevas.
         * @param {CanvasRenderingContext2D} context - Le contexte du canevas cible.
         * @param {HTMLImageElement} img - L'objet Image à dessiner.
         * @param {number} x - La coordonnée X du centre du cercle.
         * @param {number} y - La coordonnée Y du centre du cercle.
         * @param {number} diameter - Le diamètre du cercle.
         */
        function drawCircularImage(context, img, x, y, diameter) {
            const radius = diameter / 2;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = diameter;
            tempCtx.height = diameter;

            tempCtx.beginPath();
            tempCtx.arc(radius, radius, radius, 0, Math.PI * 2);
            tempCtx.closePath();
            tempCtx.clip();

            const aspectRatio = img.width / img.height;
            let drawWidth = diameter;
            let drawHeight = diameter;

            if (aspectRatio > 1) {
                drawHeight = diameter / aspectRatio;
            } else {
                drawWidth = diameter * aspectRatio;
            }

            const drawX = radius - drawWidth / 2;
            const drawY = radius - drawHeight / 2;

            tempCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            context.drawImage(tempCanvas, x - radius, y - radius, diameter, diameter);
        }

        /**
         * Dessine la grille de jeu sur le canevas principal.
         * La grille est dessinée en fonction du rectangle de calibrage.
         */
        function drawGrid() {
            if (!calibrationRect) return;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Lignes de grille semi-transparentes
            ctx.lineWidth = 1;

            const { minX, minY, maxX, maxY } = calibrationRect;
            const gridWidth = maxX - minX;
            const gridHeight = maxY - minY;

            // Lignes verticales
            for (let i = 0; i <= GRID_SIZE; i++) {
                const x = minX + (i * gridWidth / GRID_SIZE);
                ctx.beginPath();
                ctx.moveTo(x, minY);
                ctx.lineTo(x, maxY);
                ctx.stroke();
            }

            // Lignes horizontales
            for (let i = 0; i <= GRID_SIZE; i++) {
                const y = minY + (i * gridHeight / GRID_SIZE);
                ctx.beginPath();
                ctx.moveTo(minX, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }
        }

        /**
         * Convertit les coordonnées en pixels (sur le canevas principal) en coordonnées de grille (0-GRID_SIZE-1).
         * @param {number} pixelX - Coordonnée X en pixels.
         * @param {number} pixelY - Coordonnée Y en pixels.
         * @returns {object|null} - {gridX, gridY} ou null si hors grille.
         */
        function mapPixelToGrid(pixelX, pixelY) {
            if (!calibrationRect) return null;

            const { minX, minY, maxX, maxY } = calibrationRect;

            // Vérifier si le pixel est à l'intérieur du rectangle de calibrage
            if (pixelX < minX || pixelX > maxX || pixelY < minY || pixelY > maxY) {
                return null; // Hors grille
            }

            // Normaliser les coordonnées dans la plage [0, 1] par rapport au rectangle de calibrage
            const normalizedX = (pixelX - minX) / (maxX - minX);
            const normalizedY = (pixelY - minY) / (maxY - minY);

            // Convertir en coordonnées de grille (0 à GRID_SIZE-1)
            const gridX = Math.floor(normalizedX * GRID_SIZE);
            const gridY = Math.floor(normalizedY * GRID_SIZE);

            // S'assurer que les coordonnées restent dans les limites de la grille
            return {
                gridX: Math.min(Math.max(0, gridX), GRID_SIZE - 1),
                gridY: Math.min(Math.max(0, gridY), GRID_SIZE - 1)
            };
        }

        // --- Logique de la Caméra et du Canevas ---

        /**
         * Démarre le flux de la caméra et l'affiche sur le canevas.
         */
        async function startCamera() {
            displayMessage('Démarrage de la caméra...');
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } });
                videoFeed.srcObject = stream;

                await new Promise(resolve => {
                    videoFeed.onloadedmetadata = () => {
                        gameCanvas.width = videoFeed.videoWidth;
                        gameCanvas.height = videoFeed.videoHeight;

                        detectionCanvas.width = detectionWidth;
                        detectionCanvas.height = videoFeed.videoHeight * (detectionWidth / videoFeed.videoWidth);

                        displayMessage(`Caméra démarrée. Résolution: ${videoFeed.videoWidth}x${videoFeed.videoHeight}. Mode: ${currentFacingMode === 'environment' ? 'Arrière' : 'Avant'}`);
                        videoFeed.play();
                        resolve();
                    };
                });

                drawVideoFrame();
                isCameraActive = true;

                startButton.disabled = true;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                calibrateColorsButton.disabled = false; // Activer le bouton de calibration des couleurs
            } catch (err) {
                console.error("Erreur d'accès à la caméra :", err);
                displayMessage(`Impossible d'accéder à la caméra : ${err.name}. Assurez-vous d'avoir autorisé l'accès.`, 'error');
                startButton.disabled = false;
                stopButton.disabled = true;
                reverseCameraButton.disabled = true;
                calibrateColorsButton.disabled = true;
                calibrateBoardButton.disabled = true;
                isCameraActive = false;
            }
        }

        /**
         * Arrête le flux de la caméra.
         */
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                videoFeed.srcObject = null;
                stream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoFeed.pause();
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            displayMessage('Caméra arrêtée.');
            startButton.disabled = false;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            calibrateColorsButton.disabled = true;
            calibrateBoardButton.disabled = true;
            isCameraActive = false;
            isColorCalibrating = false; // Réinitialiser l'état de calibration des couleurs
            colorCalibrationStep = 'none';
            colorCalibrationControls.style.display = 'none'; // Cacher les contrôles
        }

        /**
         * Démarre le processus de calibration du plateau (4 pions bleus).
         */
        function startBoardCalibration() {
            isBoardCalibrating = true;
            calibrationPoints = [];
            calibrationRect = null;
            displayMessage('Calibrage du Plateau : Placez le premier pion BLEU (Tour) dans le coin supérieur gauche du plateau.', 'info');
            calibrateBoardButton.textContent = 'Capture Point 1';
            startButton.disabled = true;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            calibrateColorsButton.disabled = true;
            colorCalibrationControls.style.display = 'none'; // Cacher les contrôles de couleur pendant le calibrage du plateau
        }

        /**
         * Capture un point de calibrage du plateau.
         * @param {object} detectedPoint - Le point détecté {x, y}.
         */
        function captureBoardCalibrationPoint(detectedPoint) {
            if (calibrationPoints.length < 4) {
                calibrationPoints.push(detectedPoint);
                displayMessage(`Calibrage du Plateau : Point ${calibrationPoints.length} capturé. Placez le pion BLEU (Tour) dans le coin ${
                    calibrationPoints.length === 1 ? 'supérieur droit' :
                    calibrationPoints.length === 2 ? 'inférieur droit' :
                    calibrationPoints.length === 3 ? 'inférieur gauche' : ''
                } du plateau.`, 'info');
                calibrateBoardButton.textContent = `Capture Point ${calibrationPoints.length + 1}`;
            }

            if (calibrationPoints.length === 4) {
                isBoardCalibrating = false;
                calibrateBoardButton.textContent = 'Calibrer le Plateau';
                startButton.disabled = false;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                calibrateColorsButton.disabled = false;
                colorCalibrationControls.style.display = 'block'; // Afficher les contrôles de couleur après le calibrage du plateau
                
                calibrationPoints.sort((a, b) => {
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });

                calibrationRect = {
                    minX: Math.min(...calibrationPoints.map(p => p.x)),
                    minY: Math.min(...calibrationPoints.map(p => p.y)),
                    maxX: Math.max(...calibrationPoints.map(p => p.x)),
                    maxY: Math.max(...calibrationPoints.map(p => p.y))
                };

                gridCellSize.width = (calibrationRect.maxX - calibrationRect.minX) / GRID_SIZE;
                gridCellSize.height = (calibrationRect.maxY - calibrationRect.minY) / GRID_SIZE;

                displayMessage('Calibrage du Plateau terminé ! Le plateau est prêt.', 'success');
            }
        }

        /**
         * Démarre le processus de calibration des couleurs, pion par pion.
         */
        function startColorCalibration() {
            isColorCalibrating = true;
            isBoardCalibrating = false; // S'assurer que le calibrage du plateau est désactivé
            currentColorIndex = 0;
            calibrationPoints = []; // Réinitialiser les points de plateau si nécessaire
            calibrationRect = null; // Réinitialiser le rectangle du plateau
            
            // Désactiver les boutons pendant la calibration des couleurs
            startButton.disabled = true;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            calibrateBoardButton.disabled = true;
            
            colorCalibrationControls.style.display = 'block'; // Afficher les contrôles de couleur
            initColorCalibrationUI(); // S'assurer que les sliders sont initialisés

            promptNextColorCalibrationStep();
        }

        /**
         * Guide l'utilisateur à travers les étapes de calibration des couleurs.
         */
        function promptNextColorCalibrationStep() {
            if (currentColorIndex < colorCalibrationOrder.length) {
                const colorKey = colorCalibrationOrder[currentColorIndex];
                const config = colorConfigs[colorKey];
                colorCalibrationStep = `${colorKey}_pawn_placement`;
                displayMessage(`Calibration des couleurs : Placez le pion ${config.name.split(' ')[0].toUpperCase()} (${config.name.split(' ')[1].replace('(', '').replace(')', '')}) au centre de la caméra.`, 'info');
                calibrateColorsButton.textContent = `Capturer couleur ${config.name.split(' ')[0]}`;
            } else {
                // Toutes les couleurs ont été calibrées
                isColorCalibrating = false;
                colorCalibrationStep = 'complete';
                displayMessage('Calibration des couleurs terminée ! Vous pouvez maintenant calibrer le plateau ou ajuster les sliders.', 'success');
                calibrateColorsButton.textContent = 'Calibrer les Couleurs';
                
                // Réactiver les boutons
                startButton.disabled = false;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                calibrateBoardButton.disabled = false; // Activer le calibrage du plateau après calibration des couleurs
            }
        }

        /**
         * Capture la couleur du pion actuellement en cours de calibration.
         */
        function captureCurrentPawnColor() {
            const colorKey = colorCalibrationOrder[currentColorIndex];
            const config = colorConfigs[colorKey];

            const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
            const data = imageData.data;

            let rSum = 0, gSum = 0, bSum = 0;
            let pixelCount = 0;

            // Simple échantillonnage du centre de l'image de détection
            // Pour une détection plus robuste, on pourrait chercher le plus grand groupe de pixels de la couleur
            // mais pour un calibrage manuel, le centre est suffisant.
            const sampleSize = 10; // Échantillonne une petite zone au centre
            const startX = Math.max(0, Math.floor(detectionCanvas.width / 2) - sampleSize / 2);
            const startY = Math.max(0, Math.floor(detectionCanvas.height / 2) - sampleSize / 2);
            const endX = Math.min(detectionCanvas.width, startX + sampleSize);
            const endY = Math.min(detectionCanvas.height, startY + sampleSize);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const i = (y * detectionCanvas.width + x) * 4;
                    rSum += data[i];
                    gSum += data[i + 1];
                    bSum += data[i + 2];
                    pixelCount++;
                }
            }

            if (pixelCount > 0) {
                config.target.r = Math.round(rSum / pixelCount);
                config.target.g = Math.round(gSum / pixelCount);
                config.target.b = Math.round(bSum / pixelCount);
                
                // Mettre à jour les sliders UI avec les nouvelles valeurs capturées
                config.ui.rInput.value = config.target.r;
                config.ui.gInput.value = config.target.g;
                config.ui.bInput.value = config.target.b;
                updateColorFromUI(); // Met à jour les valeurs affichées à côté des sliders
                
                displayMessage(`Couleur ${config.name} capturée : R:${config.target.r}, G:${config.target.g}, B:${config.target.b}`, 'success');
                currentColorIndex++;
                promptNextColorCalibrationStep(); // Passer à l'étape suivante
            } else {
                displayMessage(`Calibration des couleurs : Aucun pion ${config.name.split(' ')[0].toUpperCase()} détecté au centre. Placez le pion et réessayez.`, 'error');
            }
        }


        /**
         * Met à jour les valeurs de couleur et de tolérance dans colorConfigs
         * à partir des sliders de l'interface utilisateur.
         */
        function updateColorFromUI() {
            for (const colorKey in colorConfigs) {
                const config = colorConfigs[colorKey];
                if (config.ui.rInput) { // Vérifier que les éléments UI existent
                    config.target.r = parseInt(config.ui.rInput.value);
                    config.target.g = parseInt(config.ui.gInput.value);
                    config.target.b = parseInt(config.ui.bInput.value);
                    config.tolerance = parseInt(config.ui.toleranceInput.value);

                    config.ui.rValue.textContent = config.target.r;
                    config.ui.gValue.textContent = config.target.g;
                    config.ui.bValue.textContent = config.target.b;
                    config.ui.toleranceValue.textContent = config.tolerance;
                }
            }
        }

        /**
         * Initialise les sliders de l'interface utilisateur avec les valeurs par défaut de colorConfigs.
         */
        function initColorCalibrationUI() {
            for (const colorKey in colorConfigs) {
                const config = colorConfigs[colorKey];
                if (config.ui.rInput) {
                    config.ui.rInput.value = config.target.r;
                    config.ui.gInput.value = config.target.g;
                    config.ui.bInput.value = config.target.b;
                    config.ui.toleranceInput.value = config.tolerance;

                    // Mettre à jour les afficheurs de valeurs
                    config.ui.rValue.textContent = config.target.r;
                    config.ui.gValue.textContent = config.target.g;
                    config.ui.bValue.textContent = config.target.b;
                    config.ui.toleranceValue.textContent = config.tolerance;

                    // Ajouter les écouteurs d'événements (seulement si pas déjà ajoutés)
                    // Pour éviter les multiples écouteurs si la fonction est appelée plusieurs fois
                    if (!config.ui.listenersAdded) {
                        config.ui.rInput.addEventListener('input', updateColorFromUI);
                        config.ui.gInput.addEventListener('input', updateColorFromUI);
                        config.ui.bInput.addEventListener('input', updateColorFromUI);
                        config.ui.toleranceInput.addEventListener('input', updateColorFromUI);
                        config.ui.listenersAdded = true;
                    }
                }
            }
        }


        /**
         * Dessine le flux vidéo sur le canevas et effectue une détection simplifiée.
         */
        function drawVideoFrame() {
            if (videoFeed.paused || videoFeed.ended || videoFeed.readyState < videoFeed.HAVE_CURRENT_DATA) {
                animationFrameId = requestAnimationFrame(drawVideoFrame);
                return;
            }

            ctx.drawImage(videoFeed, 0, 0, gameCanvas.width, gameCanvas.height);
            detectionCtx.drawImage(videoFeed, 0, 0, detectionCanvas.width, detectionCanvas.height);

            const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
            const data = imageData.data;

            // Réinitialiser les pixels détectés pour chaque couleur à chaque frame
            for (const colorKey in colorConfigs) {
                colorConfigs[colorKey].detectedPixels = [];
            }

            // Détection des pixels pour toutes les couleurs
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const x = (i / 4) % detectionCanvas.width;
                const y = Math.floor((i / 4) / detectionCanvas.width);

                for (const colorKey in colorConfigs) {
                    const config = colorConfigs[colorKey];
                    // Pendant la calibration des couleurs, on ne détecte que le pion de l'étape actuelle
                    if (isColorCalibrating && colorKey !== colorCalibrationOrder[currentColorIndex]) {
                        continue;
                    }
                    // Hors calibration des couleurs, on ne détecte pas le bleu (pion de calibrage)
                    if (!isColorCalibrating && colorKey === 'blue') {
                        continue;
                    }

                    if (Math.abs(r - config.target.r) < config.tolerance &&
                        Math.abs(g - config.target.g) < config.tolerance &&
                        Math.abs(b - config.target.b) < config.tolerance) {
                        config.detectedPixels.push({ x, y });
                    }
                }
            }

            let message = '';
            const scaleX = gameCanvas.width / detectionCanvas.width;
            const scaleY = gameCanvas.height / detectionCanvas.height;

            // --- Logique de Calibration des Couleurs ---
            if (isColorCalibrating) {
                const colorKey = colorCalibrationOrder[currentColorIndex];
                const config = colorConfigs[colorKey];

                if (config.detectedPixels.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    config.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / config.detectedPixels.length;
                    const detectionCenterY = sumY / config.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    // Dessine le pion en cours de calibration
                    if (config.tokenImage.complete && config.tokenImage.naturalHeight !== 0) {
                        drawCircularImage(ctx, config.tokenImage, centerX, centerY, tokenSize);
                    } else {
                        // Fallback avec la couleur cible
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = `rgba(${config.target.r}, ${config.target.g}, ${config.target.b}, 0.7)`;
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(config.name.split(' ')[0].toUpperCase(), centerX, centerY);
                    }
                }
                // Le message est géré par promptNextColorCalibrationStep
            }
            // --- Logique de Calibrage du Plateau ---
            else if (isBoardCalibrating) {
                const blueConfig = colorConfigs.blue;
                if (blueConfig.detectedPixels.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    blueConfig.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / blueConfig.detectedPixels.length;
                    const detectionCenterY = sumY / blueConfig.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token3Image.complete && token3Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token3Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.7)'; // Fallback bleu
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('CALIB', centerX, centerY);
                    }
                }
                // Le message de calibrage du plateau est déjà géré par captureBoardCalibrationPoint
            }
            // --- Logique de Jeu Normale (après calibrations) ---
            else {
                // --- Dessin de la grille si calibrée ---
                if (calibrationRect) {
                    drawGrid();
                }

                const redConfig = colorConfigs.red;
                const greenConfig = colorConfigs.green;

                let redDetected = false;
                let greenDetected = false;

                // Dessine le Guerrier (Rouge) si détecté
                if (redConfig.detectedPixels.length > 0) {
                    redDetected = true;
                    let sumX = 0;
                    let sumY = 0;
                    redConfig.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / redConfig.detectedPixels.length;
                    const detectionCenterY = sumY / redConfig.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token1Image.complete && token1Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token1Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = `rgba(${redConfig.target.r}, ${redConfig.target.g}, ${redConfig.target.b}, 0.7)`;
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('GUERRIER', centerX, centerY);
                    }
                    
                    const gridPos = mapPixelToGrid(centerX, centerY);
                    if (gridPos) {
                        message = `Guerrier (Rouge) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                    } else {
                        message = `Guerrier (Rouge) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                    }
                }

                // Dessine le Magicien (Vert) si détecté
                if (greenConfig.detectedPixels.length > 0) {
                    greenDetected = true;
                    let sumX = 0;
                    let sumY = 0;
                    greenConfig.detectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / greenConfig.detectedPixels.length;
                    const detectionCenterY = sumY / greenConfig.detectedPixels.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token2Image.complete && token2Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token2Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = `rgba(${greenConfig.target.r}, ${greenConfig.target.g}, ${greenConfig.target.b}, 0.7)`;
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('MAGICIEN', centerX, centerY);
                    }
                    const gridPos = mapPixelToGrid(centerX, centerY);
                    if (gridPos) {
                        if (redDetected) {
                            message += ` et Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                        } else {
                            message = `Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                        }
                    } else {
                         if (redDetected) {
                            message += ` et Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                        } else {
                            message = `Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                        }
                    }
                }

                if (!redDetected && !greenDetected) {
                    message = 'Aucun pion détecté. Placez des objets rouge et vert devant la caméra.';
                }
            }
            
            displayMessage(message);

            animationFrameId = requestAnimationFrame(drawVideoFrame);
        }

        // --- Gestionnaires d'événements ---
        startButton.addEventListener('click', startCamera);
        stopButton.addEventListener('click', stopCamera);

        reverseCameraButton.addEventListener('click', () => {
            if (stream) {
                stopCamera();
                currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                startCamera();
            }
        });

        // Gestionnaire d'événements pour le bouton de calibration des COULEURS
        calibrateColorsButton.addEventListener('click', () => {
            if (!isColorCalibrating) {
                startColorCalibration();
            } else {
                // Si on est en cours de calibration des couleurs, on capture le point actuel
                captureCurrentPawnColor();
            }
        });

        // Gestionnaire d'événements pour le bouton de calibration du PLATEAU
        calibrateBoardButton.addEventListener('click', () => {
            if (!isBoardCalibrating) {
                startBoardCalibration();
            } else {
                // Si on est déjà en calibrage du plateau, on essaie de capturer le point actuel (pion bleu)
                const blueConfig = colorConfigs.blue;
                const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
                const data = imageData.data;
                let currentBlueDetectedPixels = [];

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    if (Math.abs(r - blueConfig.target.r) < blueConfig.tolerance &&
                        Math.abs(g - blueConfig.target.g) < blueConfig.tolerance &&
                        Math.abs(b - blueConfig.target.b) < blueConfig.tolerance) {
                        const x = (i / 4) % detectionCanvas.width;
                        const y = Math.floor((i / 4) / detectionCanvas.width);
                        currentBlueDetectedPixels.push({ x, y });
                    }
                }

                if (currentBlueDetectedPixels.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    currentBlueDetectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / currentBlueDetectedPixels.length;
                    const detectionCenterY = sumY / currentBlueDetectedPixels.length;
                    const centerX = detectionCenterX * scaleX; // Convertir en coordonnées du canevas principal
                    const centerY = detectionCenterY * scaleY;

                    captureBoardCalibrationPoint({ x: centerX, y: centerY });
                } else {
                    displayMessage('Calibrage du Plateau : Aucun pion BLEU (Tour) détecté. Placez le pion et réessayez.', 'error');
                }
            }
        });


        window.addEventListener('beforeunload', stopCamera);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (stream && isCameraActive) {
                    videoFeed.pause();
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    displayMessage('Application en arrière-plan. Caméra en pause.');
                }
            } else {
                if (stream && isCameraActive) {
                    videoFeed.play();
                    drawVideoFrame();
                    displayMessage('Application revenue au premier plan. Caméra reprise.');
                }
            }
        });

        // Initialisation des sliders de calibration des couleurs au chargement de la page
        document.addEventListener('DOMContentLoaded', initColorCalibrationUI);

        // Désactivation initiale des boutons
        stopButton.disabled = true;
        reverseCameraButton.disabled = true;
        calibrateColorsButton.disabled = true; // Désactivé au démarrage, activé par startCamera
        calibrateBoardButton.disabled = true; // Désactivé au démarrage, activé après calibration des couleurs
    </script>
</body>
</html>
