<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Hybride Caméra</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Space between elements */
            padding: 1.5rem;
            max-width: 90vw;
            width: 100%;
        }
        video, canvas {
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #2d3748; /* Slightly lighter dark background for video/canvas */
            max-width: 100%;
            height: auto;
            display: block;
        }
        /* Hide the video element, we only use it to stream to canvas */
        video {
            display: none;
        }
        canvas {
            border: 2px solid #4a5568; /* Border for canvas */
        }
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        #message {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
            color: #cbd5e0;
            text-align: center;
            min-height: 2.5rem; /* Ensure consistent height */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
            }
            video, canvas {
                width: 45%; /* Adjust width for larger screens */
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div class="container">
        <h1 class="text-3xl font-bold text-center w-full">Jeu Hybride Caméra</h1>

        <!-- Video element to capture camera stream -->
        <video id="videoFeed" autoplay playsinline></video>

        <!-- Canvas element to draw video and overlays -->
        <canvas id="gameCanvas"></canvas>

        <div class="button-group w-full">
            <button id="startButton">Démarrer la Caméra</button>
            <button id="stopButton" disabled>Arrêter la Caméra</button>
            <button id="reverseCameraButton" disabled>Inverser Caméra</button>
            <button id="calibrateButton">Calibrer le Plateau</button> <!-- Nouveau bouton -->
        </div>

        <div id="message" class="w-full">Prêt à démarrer !</div>
    </div>

    <script>
        // Récupération des éléments du DOM
        const videoFeed = document.getElementById('videoFeed');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const reverseCameraButton = document.getElementById('reverseCameraButton');
        const calibrateButton = document.getElementById('calibrateButton'); // Référence au nouveau bouton
        const messageDiv = document.getElementById('message');

        let stream = null;
        let animationFrameId = null;
        let isCameraActive = false;
        let currentFacingMode = 'environment'; // 'environment' pour la caméra arrière, 'user' pour la caméra avant

        // --- Configuration des Tokens ---
        // Token 1 (Rouge) - Guerrier
        const token1ImageUrl = './assets/guerrier.png'; // URL de l'image pour le Guerrier
        const token1Image = new Image();
        token1Image.src = token1ImageUrl;
        token1Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token Guerrier. Vérifiez le chemin :", token1ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token1ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 2 (Vert) - Magicien
        const token2ImageUrl = './assets/magicien.png'; // URL de l'image pour le Magicien
        const token2Image = new Image();
        token2Image.src = token2ImageUrl;
        token2Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token Magicien. Vérifiez le chemin :", token2ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token2ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Token 3 (Bleu) - Pour le calibrage (Tour)
        const token3ImageUrl = './assets/tour.png'; // URL de l'image pour la Tour (utilisée pour le calibrage)
        const token3Image = new Image();
        token3Image.src = token3ImageUrl;
        token3Image.onerror = () => {
            console.error("Erreur de chargement de l'image du token de calibrage (Tour). Vérifiez le chemin :", token3ImageUrl);
            displayMessage(`Erreur: Impossible de charger l'image '${token3ImageUrl}'. Vérifiez le chemin et le nom du fichier.`, 'error');
        };

        // Taille personnalisable des tokens (diamètre en pixels)
        const tokenSize = 80;

        // --- Optimisation pour la détection ---
        const detectionCanvas = document.createElement('canvas');
        const detectionCtx = detectionCanvas.getContext('2d');
        const detectionWidth = 160; // Résolution de détection

        // --- Variables de calibrage ---
        const GRID_SIZE = 10; // Grille 10x10
        let isCalibrating = false;
        let calibrationPoints = []; // Pour stocker les 4 points de calibrage (x, y)
        let calibrationRect = null; // { minX, minY, maxX, maxY } du rectangle de calibrage en pixels
        let gridCellSize = { width: 0, height: 0 }; // Taille d'une cellule de grille en pixels

        // --- Fonctions utilitaires ---

        /**
         * Affiche un message à l'utilisateur.
         * @param {string} msg - Le message à afficher.
         * @param {string} type - Le type de message ('info', 'error', 'success').
         */
        function displayMessage(msg, type = 'info') {
            messageDiv.textContent = msg;
            messageDiv.className = `w-full p-3 rounded-lg text-center ${
                type === 'error' ? 'bg-red-700 text-white' :
                type === 'success' ? 'bg-green-700 text-white' :
                'bg-gray-700 text-gray-200'
            }`;
        }

        /**
         * Convertit une couleur hexadécimale en objet RGB.
         * @param {string} hex - La couleur hexadécimale (ex: "#FF0000").
         * @returns {object} - Un objet {r, g, b}.
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        /**
         * Dessine une image dans un cercle sur un contexte de canevas.
         * @param {CanvasRenderingContext2D} context - Le contexte du canevas cible.
         * @param {HTMLImageElement} img - L'objet Image à dessiner.
         * @param {number} x - La coordonnée X du centre du cercle.
         * @param {number} y - La coordonnée Y du centre du cercle.
         * @param {number} diameter - Le diamètre du cercle.
         */
        function drawCircularImage(context, img, x, y, diameter) {
            const radius = diameter / 2;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = diameter;
            tempCtx.height = diameter;

            tempCtx.beginPath();
            tempCtx.arc(radius, radius, radius, 0, Math.PI * 2);
            tempCtx.closePath();
            tempCtx.clip();

            const aspectRatio = img.width / img.height;
            let drawWidth = diameter;
            let drawHeight = diameter;

            if (aspectRatio > 1) {
                drawHeight = diameter / aspectRatio;
            } else {
                drawWidth = diameter * aspectRatio;
            }

            const drawX = radius - drawWidth / 2;
            const drawY = radius - drawHeight / 2;

            tempCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            context.drawImage(tempCanvas, x - radius, y - radius, diameter, diameter);
        }

        /**
         * Dessine la grille de jeu sur le canevas principal.
         * La grille est dessinée en fonction du rectangle de calibrage.
         */
        function drawGrid() {
            if (!calibrationRect) return;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Lignes de grille semi-transparentes
            ctx.lineWidth = 1;

            const { minX, minY, maxX, maxY } = calibrationRect;
            const gridWidth = maxX - minX;
            const gridHeight = maxY - minY;

            // Lignes verticales
            for (let i = 0; i <= GRID_SIZE; i++) {
                const x = minX + (i * gridWidth / GRID_SIZE);
                ctx.beginPath();
                ctx.moveTo(x, minY);
                ctx.lineTo(x, maxY);
                ctx.stroke();
            }

            // Lignes horizontales
            for (let i = 0; i <= GRID_SIZE; i++) {
                const y = minY + (i * gridHeight / GRID_SIZE);
                ctx.beginPath();
                ctx.moveTo(minX, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }
        }

        /**
         * Convertit les coordonnées en pixels (sur le canevas principal) en coordonnées de grille (0-GRID_SIZE-1).
         * @param {number} pixelX - Coordonnée X en pixels.
         * @param {number} pixelY - Coordonnée Y en pixels.
         * @returns {object|null} - {gridX, gridY} ou null si hors grille.
         */
        function mapPixelToGrid(pixelX, pixelY) {
            if (!calibrationRect) return null;

            const { minX, minY, maxX, maxY } = calibrationRect;

            // Vérifier si le pixel est à l'intérieur du rectangle de calibrage
            if (pixelX < minX || pixelX > maxX || pixelY < minY || pixelY > maxY) {
                return null; // Hors grille
            }

            // Normaliser les coordonnées dans la plage [0, 1] par rapport au rectangle de calibrage
            const normalizedX = (pixelX - minX) / (maxX - minX);
            const normalizedY = (pixelY - minY) / (maxY - minY);

            // Convertir en coordonnées de grille (0 à GRID_SIZE-1)
            const gridX = Math.floor(normalizedX * GRID_SIZE);
            const gridY = Math.floor(normalizedY * GRID_SIZE);

            // S'assurer que les coordonnées restent dans les limites de la grille
            return {
                gridX: Math.min(Math.max(0, gridX), GRID_SIZE - 1),
                gridY: Math.min(Math.max(0, gridY), GRID_SIZE - 1)
            };
        }

        // --- Logique de la Caméra et du Canevas ---

        /**
         * Démarre le flux de la caméra et l'affiche sur le canevas.
         */
        async function startCamera() {
            displayMessage('Démarrage de la caméra...');
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } });
                videoFeed.srcObject = stream;

                await new Promise(resolve => {
                    videoFeed.onloadedmetadata = () => {
                        gameCanvas.width = videoFeed.videoWidth;
                        gameCanvas.height = videoFeed.videoHeight;

                        detectionCanvas.width = detectionWidth;
                        detectionCanvas.height = videoFeed.videoHeight * (detectionWidth / videoFeed.videoWidth);

                        displayMessage(`Caméra démarrée. Résolution: ${videoFeed.videoWidth}x${videoFeed.videoHeight}. Mode: ${currentFacingMode === 'environment' ? 'Arrière' : 'Avant'}`);
                        videoFeed.play();
                        resolve();
                    };
                });

                drawVideoFrame();
                isCameraActive = true;

                startButton.disabled = true;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                calibrateButton.disabled = false; // Activer le bouton de calibrage
            } catch (err) {
                console.error("Erreur d'accès à la caméra :", err);
                displayMessage(`Impossible d'accéder à la caméra : ${err.name}. Assurez-vous d'avoir autorisé l'accès.`, 'error');
                startButton.disabled = false;
                stopButton.disabled = true;
                reverseCameraButton.disabled = true;
                calibrateButton.disabled = true; // Désactiver le bouton de calibrage
                isCameraActive = false;
            }
        }

        /**
         * Arrête le flux de la caméra.
         */
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                videoFeed.srcObject = null;
                stream = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            videoFeed.pause();
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            displayMessage('Caméra arrêtée.');
            startButton.disabled = false;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
            calibrateButton.disabled = true; // Désactiver le bouton de calibrage
            isCameraActive = false;
        }

        /**
         * Démarre le processus de calibrage.
         */
        function startCalibration() {
            isCalibrating = true;
            calibrationPoints = [];
            calibrationRect = null;
            displayMessage('Calibrage : Placez le premier pion BLEU (Tour) dans le coin supérieur gauche du plateau.', 'info');
            calibrateButton.textContent = 'Capture Point 1';
            startButton.disabled = true;
            stopButton.disabled = true;
            reverseCameraButton.disabled = true;
        }

        /**
         * Capture un point de calibrage.
         * @param {object} detectedPoint - Le point détecté {x, y}.
         */
        function captureCalibrationPoint(detectedPoint) {
            if (calibrationPoints.length < 4) {
                calibrationPoints.push(detectedPoint);
                displayMessage(`Calibrage : Point ${calibrationPoints.length} capturé. Placez le pion BLEU (Tour) dans le coin ${
                    calibrationPoints.length === 1 ? 'supérieur droit' :
                    calibrationPoints.length === 2 ? 'inférieur droit' :
                    calibrationPoints.length === 3 ? 'inférieur gauche' : ''
                } du plateau.`, 'info');
                calibrateButton.textContent = `Capture Point ${calibrationPoints.length + 1}`;
            }

            if (calibrationPoints.length === 4) {
                isCalibrating = false;
                calibrateButton.textContent = 'Calibrer le Plateau';
                startButton.disabled = false;
                stopButton.disabled = false;
                reverseCameraButton.disabled = false;
                
                // Sortir les points par Y puis par X pour assurer un ordre (haut-gauche, haut-droit, bas-gauche, bas-droit)
                // C'est une simplification, une vraie homographie serait plus robuste à l'ordre.
                calibrationPoints.sort((a, b) => {
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });

                // Définir le rectangle de calibrage (minX, minY, maxX, maxY)
                // On prend le min/max des 4 points pour former un rectangle englobant
                calibrationRect = {
                    minX: Math.min(...calibrationPoints.map(p => p.x)),
                    minY: Math.min(...calibrationPoints.map(p => p.y)),
                    maxX: Math.max(...calibrationPoints.map(p => p.x)),
                    maxY: Math.max(...calibrationPoints.map(p => p.y))
                };

                // Calculer la taille d'une cellule de grille en pixels
                gridCellSize.width = (calibrationRect.maxX - calibrationRect.minX) / GRID_SIZE;
                gridCellSize.height = (calibrationRect.maxY - calibrationRect.minY) / GRID_SIZE;

                displayMessage('Calibrage terminé ! Le plateau est prêt.', 'success');
            }
        }

        /**
         * Dessine le flux vidéo sur le canevas et effectue une détection simplifiée.
         */
        function drawVideoFrame() {
            if (videoFeed.paused || videoFeed.ended || videoFeed.readyState < videoFeed.HAVE_CURRENT_DATA) {
                animationFrameId = requestAnimationFrame(drawVideoFrame);
                return;
            }

            ctx.drawImage(videoFeed, 0, 0, gameCanvas.width, gameCanvas.height);
            detectionCtx.drawImage(videoFeed, 0, 0, detectionCanvas.width, detectionCanvas.height);

            const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
            const data = imageData.data;

            // Couleurs cibles et tolérances
            const targetColor1 = hexToRgb("#FF0000"); // Rouge (Guerrier)
            const tolerance1 = 75;
            const targetColor2 = hexToRgb("#00FF00"); // Vert (Magicien)
            const tolerance2 = 75;
            const targetColor3 = hexToRgb("#0000FF"); // Bleu (Tour pour calibrage)
            const tolerance3 = 75;

            let detectedPixels1 = []; // Rouge (Guerrier)
            let detectedPixels2 = []; // Vert (Magicien)
            let detectedPixels3 = []; // Bleu (pour calibrage - Tour)

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const x = (i / 4) % detectionCanvas.width;
                const y = Math.floor((i / 4) / detectionCanvas.width);

                // Détection du Token 1 (Rouge - Guerrier)
                if (Math.abs(r - targetColor1.r) < tolerance1 &&
                    Math.abs(g - targetColor1.g) < tolerance1 &&
                    Math.abs(b - targetColor1.b) < tolerance1) {
                    detectedPixels1.push({ x, y });
                }
                
                // Détection du Token 2 (Vert - Magicien)
                if (Math.abs(r - targetColor2.r) < tolerance2 &&
                    Math.abs(g - targetColor2.g) < tolerance2 &&
                    Math.abs(b - targetColor2.b) < tolerance2) {
                    detectedPixels2.push({ x, y });
                }

                // Détection du Token 3 (Bleu - Tour) - UNIQUEMENT pendant le calibrage
                if (isCalibrating &&
                    Math.abs(r - targetColor3.r) < tolerance3 &&
                    Math.abs(g - targetColor3.g) < tolerance3 &&
                    Math.abs(b - targetColor3.b) < tolerance3) {
                    detectedPixels3.push({ x, y });
                }
            }

            let message = 'Aucun pion détecté. Placez des objets rouge et vert devant la caméra.';
            const scaleX = gameCanvas.width / detectionCanvas.width;
            const scaleY = gameCanvas.height / detectionCanvas.height;

            // --- Logique de Calibrage ---
            if (isCalibrating) {
                if (detectedPixels3.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    detectedPixels3.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / detectedPixels3.length;
                    const detectionCenterY = sumY / detectedPixels3.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    // Dessine le pion bleu (Tour) en cours de détection
                    if (token3Image.complete && token3Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token3Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.7)'; // Fallback bleu
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('CALIB', centerX, centerY);
                    }
                }
                // Le message de calibrage est déjà géré par captureCalibrationPoint
            } else {
                // --- Dessin de la grille si calibrée ---
                if (calibrationRect) {
                    drawGrid();
                }

                // --- Dessine le Token 1 (Rouge - Guerrier) si détecté ---
                if (detectedPixels1.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    detectedPixels1.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / detectedPixels1.length;
                    const detectionCenterY = sumY / detectedPixels1.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token1Image.complete && token1Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token1Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; // Fallback rouge
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('GUERRIER', centerX, centerY);
                    }
                    
                    const gridPos = mapPixelToGrid(centerX, centerY);
                    if (gridPos) {
                        message = `Guerrier (Rouge) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                    } else {
                        message = `Guerrier (Rouge) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                    }
                }

                // --- Dessine le Token 2 (Vert - Magicien) si détecté ---
                if (detectedPixels2.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    detectedPixels2.forEach(p => { sumX += p.x; sumY += p.y; });
                    const detectionCenterX = sumX / detectedPixels2.length;
                    const detectionCenterY = sumY / detectedPixels2.length;
                    const centerX = detectionCenterX * scaleX;
                    const centerY = detectionCenterY * scaleY;

                    if (token2Image.complete && token2Image.naturalHeight !== 0) {
                        drawCircularImage(ctx, token2Image, centerX, centerY, tokenSize);
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tokenSize / 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.7)'; // Fallback vert
                        ctx.fill();
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.closePath();
                        ctx.fillStyle = 'white';
                        ctx.font = `${tokenSize / 3}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('MAGICIEN', centerX, centerY);
                    }
                    const gridPos = mapPixelToGrid(centerX, centerY);
                    if (gridPos) {
                        if (detectedPixels1.length > 0) {
                            message += ` et Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                        } else {
                            message = `Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Grille: ${gridPos.gridX}, ${gridPos.gridY}) !`;
                        }
                    } else {
                         if (detectedPixels1.length > 0) {
                            message += ` et Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                        } else {
                            message = `Magicien (Vert) détecté à X:${Math.round(centerX)}, Y:${Math.round(centerY)} (Hors grille) !`;
                        }
                    }
                }
            }
            
            displayMessage(message);

            animationFrameId = requestAnimationFrame(drawVideoFrame);
        }

        // --- Gestionnaires d'événements ---
        startButton.addEventListener('click', startCamera);
        stopButton.addEventListener('click', stopCamera);

        reverseCameraButton.addEventListener('click', () => {
            if (stream) {
                stopCamera();
                currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                startCamera();
            }
        });

        // Gestionnaire d'événements pour le bouton de calibrage
        calibrateButton.addEventListener('click', () => {
            if (!isCalibrating) {
                startCalibration();
            } else {
                // Si on est déjà en calibrage, on essaie de capturer le point actuel
                if (calibrationPoints.length < 4) {
                    // Pour capturer le point, on prend la position du pion bleu s'il est détecté
                    // Cette partie est un peu simplifiée : dans une vraie app, on attendrait que l'utilisateur
                    // valide le placement du pion avant de le capturer. Ici, on le capture au clic si détecté.
                    // Pour une meilleure UX, on pourrait ajouter un bouton "Capturer ce point"
                    // après avoir détecté le pion bleu.
                    // Pour l'instant, on se base sur la détection du pion bleu au moment du clic.
                    const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
                    const data = imageData.data;
                    const targetColor3 = hexToRgb("#0000FF"); // Bleu (Calibrage)
                    const tolerance3 = 75;
                    let currentBlueDetectedPixels = [];

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        if (Math.abs(r - targetColor3.r) < tolerance3 &&
                            Math.abs(g - targetColor3.g) < tolerance3 &&
                            Math.abs(b - targetColor3.b) < tolerance3) {
                            const x = (i / 4) % detectionCanvas.width;
                            const y = Math.floor((i / 4) / detectionCanvas.width);
                            currentBlueDetectedPixels.push({ x, y });
                        }
                    }

                    if (currentBlueDetectedPixels.length > 0) {
                        let sumX = 0;
                        let sumY = 0;
                        currentBlueDetectedPixels.forEach(p => { sumX += p.x; sumY += p.y; });
                        const detectionCenterX = sumX / currentBlueDetectedPixels.length;
                        const detectionCenterY = sumY / currentBlueDetectedPixels.length;
                        const centerX = detectionCenterX * scaleX; // Convertir en coordonnées du canevas principal
                        const centerY = detectionCenterY * scaleY;

                        captureCalibrationPoint({ x: centerX, y: centerY });
                    } else {
                        displayMessage('Calibrage : Aucun pion BLEU (Tour) détecté. Placez le pion et réessayez.', 'error');
                    }
                }
            }
        });


        window.addEventListener('beforeunload', stopCamera);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (stream && isCameraActive) {
                    videoFeed.pause();
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    displayMessage('Application en arrière-plan. Caméra en pause.');
                }
            } else {
                if (stream && isCameraActive) {
                    videoFeed.play();
                    drawVideoFrame();
                    displayMessage('Application revenue au premier plan. Caméra reprise.');
                }
            }
        });

        stopButton.disabled = true;
        reverseCameraButton.disabled = true;
        calibrateButton.disabled = true; // Désactiver le bouton de calibrage au démarrage, activé par startCamera
    </script>
</body>
</html>
